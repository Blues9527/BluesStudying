# 1.排序算法

- 直接插入排序

思路：在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

```
private static void insertSort(int[] nums) {
		int len = nums.length;
		int insertNum;
		for (int i = 1; i < len; i++) {
			insertNum = nums[i];
			int j =i-1;
			while(j>=0 && nums[j] > insertNum) {
				nums[j+1] = nums[j];
				j--;
			}
			nums[j+1] = insertNum;
		}
	}
```

- 希尔排序

思路：将数的个数设为n，取奇数k=n/2，将下标差值为k的数分为一组，构成有序序列。
再取k=k/2 ，将下标差值为k的书分为一组，构成有序序列。
重复第二步，直到k=1执行简单插入排序。

```
private static void sheelSort(int[] nums) {
		int len= nums.length;
		while(len!=0) {
			len = len/2;
			for(int i=0;i<len;i++) {
				for(int j = i+len;j<nums.length;j+=len) {
					int k = j-len;
					int temp = nums[j];
					while(k>=0&& temp<nums[k]) {
						nums[k+len]= nums[k];
						k-=len;
					}
					nums[k+len] = temp;
				}
			}
		}
	}
```

- 简单选择排序

思路：遍历整个序列，将最小的数放在最前面。
遍历剩下的序列，将最小的数放在最前面。
重复第二步，直到只剩下一个数。

```
private static void selectSort(int[] nums) {
		int len = nums.length;
		for(int i=0;i<len;i++) {
			int currentNum = nums[i];
			int index =i;
			for(int j=i+1;j<len;j++) {
				if (nums[j]<currentNum) {
					currentNum = nums[j];
					index = j;
				}
			}
			nums[index] = nums[i];
			nums[i] = currentNum;
		}
	}
```

- 堆排序

思路：将序列构建成大顶堆。
将根节点与最后一个节点交换，然后断开最后一个节点。
重复第一、二步，直到所有节点断开。

```
private static void heapSort(int[] a) {
		int len = a.length;
		// 循环建堆
		for (int i = 0; i < len - 1; i++) {
			// 建堆
			buildMaxHeap(a, len - 1 - i);
			// 交换堆顶和最后一个元素
			swap(a, 0, len - 1 - i);
		}
	}

	// 交换方法
	private static void swap(int[] data, int i, int j) {
		int tmp = data[i];
		data[i] = data[j];
		data[j] = tmp;
	}

	// 对data数组从0到lastIndex建大顶堆
	private static void buildMaxHeap(int[] data, int lastIndex) {
		// 从lastIndex处节点（最后一个节点）的父节点开始
		for (int i = (lastIndex - 1) / 2; i >= 0; i--) {
			// k保存正在判断的节点
			int k = i;
			// 如果当前k节点的子节点存在
			while (k * 2 + 1 <= lastIndex) {
				// k节点的左子节点的索引
				int biggerIndex = 2 * k + 1;
				// 如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在
				if (biggerIndex < lastIndex) {
					// 若果右子节点的值较大
					if (data[biggerIndex] < data[biggerIndex + 1]) {
						// biggerIndex总是记录较大子节点的索引
						biggerIndex++;
					}
				}
				// 如果k节点的值小于其较大的子节点的值
				if (data[k] < data[biggerIndex]) {
					// 交换他们
					swap(data, k, biggerIndex);
					// 将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值
					k = biggerIndex;
				} else {
					break;
				}
			}
		}
	}
```

- 冒泡排序


思路：循环，两两交换。

```

private static void bubbleSort(int[] a) {
		int len = a.length;
		for (int i = 0; i < len; i++) {
			for (int j = 0; j < len - i - 1; j++) {// 注意第二重循环的条件
				if (a[j] > a[j + 1]) {
					int temp = a[j];
					a[j] = a[j + 1];
					a[j + 1] = temp;
				}
			}
		}
	}
	
```

- 快速排序

思路：选择第一个数为p，小于p的数放在左边，大于p的数放在右边。

递归的将p左边和右边的数都按照第一步进行，直到不能递归。

```
private static void quickSort(int[] a, int start, int end) {
		if (start < end) {
			int baseNum = a[start];// 选基准值
			int midNum;// 记录中间值
			int i = start;
			int j = end;
			do {
				while ((a[i] < baseNum) && i < end) {
					i++;
				}
				while ((a[j] > baseNum) && j > start) {
					j--;
				}
				if (i <= j) {
					midNum = a[i];
					a[i] = a[j];
					a[j] = midNum;
					i++;
					j--;
				}
			} while (i <= j);
			if (start < j) {
				quickSort(a, start, j);
			}
			if (end > i) {
				quickSort(a, i, end);
			}
		}
	}
```

- 归并排序

思路：选择相邻两个数组成一个有序序列。
选择相邻的两个有序序列组成一个有序序列。
重复第二步，直到全部组成一个有序序列

```
private static void mergeSort(int[] a, int left, int right) {
		int t = 1;// 每组元素个数
		int size = right - left + 1;
		while (t < size) {
			int s = t;// 本次循环每组元素个数
			t = 2 * s;
			int i = left;
			while (i + (t - 1) < size) {
				merge(a, i, i + (s - 1), i + (t - 1));
				i += t;
			}
			if (i + (s - 1) < right)
				merge(a, i, i + (s - 1), right);
		}
	}

	private static void merge(int[] data, int p, int q, int r) {
		int[] B = new int[data.length];
		int s = p;
		int t = q + 1;
		int k = p;
		while (s <= q && t <= r) {
			if (data[s] <= data[t]) {
				B[k] = data[s];
				s++;
			} else {
				B[k] = data[t];
				t++;
			}
			k++;
		}
		if (s == q + 1)
			B[k++] = data[t++];
		else
			B[k++] = data[s++];
		for (int i = p; i <= r; i++)
			data[i] = B[i];
	}
```

# 2.二叉树的遍历
- 前（先）序遍历
 思路：从根结点出发，先遍历完左边，再遍历右边

- 中序遍历
 思路：先从左子树出发，然后再到根结点，再遍历又子树

- 后序遍历
 思路：先从左子树出发，然后再遍历右子树，最后是根结点


