# OSI模型

###### 高->低
1. 应用层(FTP/HTTP/Telnet/DNS)
2. 表示层
3. 会话层
4. 传输层(TCP/UDP)）
5. 网络层
6. 数据链路层
7. 物理层


# TCP/IP模型
1. 应用层(HTTP/Telnet/FTP/DNS/SMTP)
2. 传输层(TCP/UDP)
3. 网络层(IP)
4. 数据链路层
5. 物理层(中继器、集线器、双绞线)


# TCP

### 三次握手


###### 第一次握手
建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。

###### 第二次握手
服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。


###### 第三次握手
客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。

### 为什么是三次握手？
因为TCP是全双工的（客户端在给服务端发送消息的同时，服务端也可以给客户端发送消息），如果是两次握手，服务端无法确认客户端是否有收到消息，所以需要客户端再发送确认消息才算是建立连接。如果是四次，则造成浪费。

### 四次挥手

###### 第一次挥手
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。

###### 第二次挥手
服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。

###### 第三次挥手
关闭服务器到客户端的连接，发送一个FIN给客户端。

###### 第四次挥手
客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

### 为什么是四次挥手？
TCP是全双工的，双方关闭连接要经过双方都同意。所以，首先是客服端给服务器发送FIN，要求关闭连接，服务器收到后会发送一个ACK进行确认。服务器然后再发送一个FIN，客户端发送ACK确认，并进入TIME_WAIT状态。等待2MSL后自动关闭。

# Https原理及组成
[转自@wbxjiayou](https://www.cnblogs.com/wbxjiayou/p/5157395.html)

Https = Http + TLS/SSL
> 1. 握手的时候使用的非对称加密算法 ，用来加密握手之后的请求和应答
> 2. 传输信息的时候使用的对称加密，
> 3. 保证数据的完整性用的是hash算法(数字签名)

###### 工作原理
1.客户端发起HTTPS请求
2.服务器的配置(数字证书)
3.传送证书
4.客户端解析证书
5.传送加密信息
6.服务端解密信息
7.传输加密后的信息
8.客户端解密信息

# http请求头
[可参考](https://blog.csdn.net/danielzhou888/article/details/72861097)
> content-type的类型
- application/json : json格式数据
- text/xml : xml格式数据
- multipart/form-data
- application/x-www-form-urlencoded
- text/plain :纯文本